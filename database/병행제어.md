# 병행제어
1. 대부분의 DBMS는 다수의 사용자
2. 여러 사용자들이 동시에 동일한 테이블에 접근할 수 있음
3. DBMS의 성능을 높이기 위해 여러사용자가 동시에 수행하는 것이 필수적
4. 병행제어는 여러 사용자들이 다수의 트랜잭션을 동시에 수행할때 트랜잭션들 간의 간섭이 생기지 않게함 (무결성 손상 방지)

### how?
1. 직렬스케줄
 - 여러 트랜잭션들이 순서대로 차례대로 수행함
2. 비직렬스케줄
 - 여러 트랜잭션들을 동시에 수행함
 - 직렬스케줄 = 비직렬스케줄 결과가 동일한 것을 "직렬가능"이라 한다

### 병행제어를 하지않는다면?
1. 갱신손실(lost update) : 수행중인 트랜잭션이 갱신한 내용을 다를 트랜잭션이 덮어씀
2. 오손 데이터 읽기(dirty read) : 완료되지않은 트랜잭션이 갱신한 데이터(commit이 안된 데이터)를 읽은것
3. 반복할 수 없는 읽기(unrepeatable read) : 한 트랜잭션이 동일한 데이터를 두번 읽을때 다른값이 읽히는 것
4. phantom read : ?

### 로킹
동시에 수행되는 트랜잭션들의 동시성을 제어하기위해 널리 사용되는 기법
1. lock는 데이터베이스 내의 각 테이터 항목과 연관된 하나의 변수
2. 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 lock에 대한 정보는 lock table에 유지
3. 트랜잭션에서 갱신을 목적으로 데이터에 접근할떄 독점로크(X-lock)를 요청함
4. 트랜잭션에서 읽을 목적으로 데이터에 접근할때 공유로크(S-lock)을 요청함
5. 트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에는 lock를 해제함

### 2단계 로킹 프로토콜
1. 로크를 한개라도 해제하면 다시 로크를 요청하지 못함
2. 필요한 모든 데이터에 대하여 먼저 로크를 요청 후 순차적으로 로크를 해제
3. 로크 확장단계
 - 트랜잭션이 새로운 로크를 요청할수 있지만 해재 할 수 없음
 - 로크포인트 : 한 트랜잭션에서 필요로 하는 모든 로크를 요청한 시점
4. 로크 수축단계
 - 트랜잭션이 보유중인 로크를 해제할 수 있지만 새로 요청할 수 없음
 - 트랜잭션 완료 시점에서 한꺼번에 모든 로크를 해제할 수 있고 일반적으로 사용됨
5. 데드락이 발생할 수 있다.
 - 데드락 : 두개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 로크를 요청하면서 대기중인 상태
 - 데드락을 방지하는 기법이나, 데드락을 탐지하고 희생자를 선정하여 데드락을 푸는 기법 등