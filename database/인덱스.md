# 인덱스
1. 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
2. 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회

### 인덱스의 관리
DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다
1. INSERT: 새로운 데이터에 대한 인덱스를 추가함
2. DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
3. UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

### 장점
1. 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
2. 전반적인 시스템의 부하를 줄일 수 있다.

### 단점
1. 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
2. 인덱스를 관리하기 위해 추가 작업이 필요하다.
3. 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.


만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.

### 인덱스를 걸어야 할 컬럼
1. WHERE 절에서 자주 사용되는 컬럼
2. 자주 검색되는 컬럼(SELECT 절에서)
3. 기본 키는 자동적으로 클러스터 인덱스가 만들어 진다.
4. 참조 키(Foreign Key)에 인덱스를 걸면 조인 사용할 때에 조인의 속도를 향상시킨다. 색인이 자동적으로 만들어지지 않는다.
5. 자주 JOIN으로 사용하는 컬럼(참조 키가 아닐 때)
6. 정렬된 순서로 자주 사용되는 컬럼(가능하다면 클러스터 인덱스를 만드는 것이 좋다)
7. 범위를 주고 찾는 컬럼(가능하다면 클러스터 인덱스를 만드는 것이 좋다)

### 인덱스를 걸지 않아야 할 컬럼
1. 좀처럼 검색되지 않는 컬럼
2. 전체 중 상당 부분을 가져오는 질의에 사용되는 컬럼
3. 유일성, 또는 같은 값이 많은 컬럼
4. SELECT 속도보다 데이터의 변경 속도가 훨씬 중요할 때(되도록 색인의 수를 최소화 한다.)
5. 데이터의 변경이 잦의 컬럼

### 클러스터 인덱스 (Clustered Index)

1. 테이블마다 단 한개의 클러스터 인덱스가 존재한다.
2. 물리적인 행(데이터)의 순서가 인덱스의 순서와 동일하다.
3. 인덱스의 맨 마지막 단계인 리프 레벨(Leaf Level)이 곧 데이터 페이지이다.
4. 실제 데이터의 순서와 인덱스의 순서가 일치하기 때문에 일정한 범위를 주고 찾는 경우 속도 향상에 도움이 된다.
5. Non-Clustered Index에 비해 색인의 단계가 한 단계 적기 때문에 색인의 크기도 작고 그만큼 빨리 찾을 수 있다.
6. 새로운 데이터가 입력되면 항상 물리적 순서를 색인의 순서에 맞추어야 하기 때문에 많은 데이터가 자신의 자리를 찾는 작업을 해야 하므로 이 부분에서는 오히려 넌클러스터드 인덱스보다 느리다.


### 넌-클러스터 인덱스 (Non-Clustered Index)

1. 물리적인 행의 순서가 색인의 순서와 동일하지 않다.
2. 브랜치 레벨은 데이터 페이지가 아니다.
3. 브랜치 레벨에서 한 단계 더 내려가야만 데이터 페이지이다. 따라서 클러스터 색인보다 한 단계를 더 거쳐야 실제 찾고자 하는 데이터에 도달할 수 있다.


|구분|	 클러스터 인덱스| 넌클러스터 인덱스|
|----|-----------------------|------------------|
|차이|	 물리적으로 행을 재배열|	 물리적으로 재배열 하지 않는다.|
|크기|	 인덱스 페이지 용량이 넌 클러스터드 인덱스 페이지 용량보다 작다.| 클러스터드 인덱스 페이지 용량보다 크다.|
|선택도|	 30% 이내에서 사용해야 좋은 선택도|	 3% 이내에서 사용해야 좋은 선택도|
|최대 갯수|	 테이블당 1개|	 테이블당 249개|


클러스터 인덱스
![클러스터인덱스](https://user-images.githubusercontent.com/67908647/117973678-a53a5900-b367-11eb-92d7-2468183b7976.png)

넌클러스터 인덱스
![넌인덱스](https://user-images.githubusercontent.com/67908647/117973687-a7041c80-b367-11eb-9bdb-e2129d32568a.png)


~~~SQL
## 클러스터 인덱스 작성
CREATE CLUSTERED INDEX '인덱스 이름' ON '테이블 이름' ('컬럼 이름');

## 넌클러스터 인덱스 작성
CREATE NONCLUSTERED INDEX '인덱스 이름' ON '테이블 이름' ('컬럼 이름');
~~~

Full Table Scan : 대용량 데이터, 비효율적

Range Scan : 인덱스를 활용, 특정 범위만 스캔

select (from where)효율적
insert delete update 비효율적

index 설정기준? -> 고유값
